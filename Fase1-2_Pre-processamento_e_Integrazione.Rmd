---
title: "Fasi 1–2: Pre-processamento e Integrazione"
author: "Giacomo Pensiero"
date: "2025-10-01"
output: html_document
---

## Fasi 1–2: Pre-processamento e Integrazione

In questo script vengono eseguite le Fasi 1–2 dell’analisi sul dataset snRNA-seq di Eom et al. (2024), scaricato dal repository GEO (GSE254044). Le fasi includono: importazione delle matrici di conteggio 10x e creazione degli oggetti Seurat per ciascun campione, annotazione dei metadati, caricamento delle liste geniche del ciclo cellulare da Seurat e conversione Human→Mouse utilizzando una tabella di ortologhi scaricata da Ensembl BioMart, controllo qualità e filtraggio, correzione dell’effetto del ciclo cellulare, identificazione e rimozione dei doublet e integrazione CCA.

```{r setup, eval=TRUE, echo=TRUE}
knitr::opts_chunk$set()
options(scipen = 999)
set.seed(1234)
```

```{r load-packages, eval=TRUE,echo=TRUE, message=FALSE, warning=FALSE}
library(Seurat)
library(tidyverse)
library(patchwork)
library(Matrix)
library(DoubletFinder)
library(KernSmooth)
library(purrr)
library(ggplot2)
library(scales)
```

```{r path, eval=TRUE, echo=TRUE}
base_path <- "C:/Users/giaco/OneDrive/Desktop/TBX1"
samples_path <- paste0(base_path, "/Dati_Input/Campioni/")
plots_path <- paste0(base_path,"/Analisi_Giacomo/grafici/graf_prep_integrazione/")
intermediate_pre_path <- paste0(base_path, "/Analisi_Giacomo/intermediate/pre_integrazione/")
```

## Importazione dei dati di espressione genica (snRNA-seq)

In questa sezione vengono importate le matrici di conteggio 10x dei quattro campioni (*bone_WT1*, *bone_WT2*, *bone_MUT1*, *bone_MUT2*) e, per ciascun campione, viene costruito un oggetto Seurat. A ogni oggetto vengono associati i metadati di campione (*sample*) e di condizione sperimentale (*condition: WT o MUT*). Infine, gli oggetti sono raccolti in una lista (*seurat_list*) sulla quale verranno applicati i passaggi successivi dell’analisi.

```{r load-data-seurat-style, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
samples <- c("bone_WT1", "bone_WT2", "bone_MUT1", "bone_MUT2")
seurat_list <- list()
for (s in samples) {
  path <- paste0(samples_path, s, "/filtered_feature_bc_matrix")
  counts <- Read10X(data.dir = path)
  obj <- CreateSeuratObject(
    counts = counts,
    project = s)
  obj$sample    <- s
  obj$condition <- ifelse(grepl("WT", s), "WT", "MUT")
  seurat_list[[s]] <- obj
}
names(seurat_list) <- samples
```

## Caricamento liste geniche del ciclo cellulare

Le liste di riferimento per lo scoring del ciclo cellulare (fasi *S* e *G2/M*) sono state ottenute da Seurat (*cc.genes.updated.2019*). Poiché tali liste sono definite in simboli genici umani, è stata effettuata una conversione Human→Mouse utilizzando una tabella di ortologhi (*human_mouse_ortholog.csv*) scaricata da Ensembl BioMart. La conversione è stata eseguita costruendo una mappatura tra simboli umani e murini, rimuovendo i geni senza corrispondenza e deduplicando i risultati, ottenendo le liste finali *s.genes* e *g2m.genes*.

```{r define-cycle-genes, eval=TRUE, echo=TRUE}
orthologs <- read.csv(
  paste0(samples_path, "human_mouse_ortholog.csv"),
  stringsAsFactors = FALSE
)
gene_map <- setNames(orthologs$Mouse.Symbol, orthologs$Human.Symbol)
convert_to_mouse <- function(genes, map = gene_map) {
  converted <- ifelse(genes %in% names(map), map[genes], NA)
  converted <- converted[!is.na(converted)]
  unique(converted)
}
s.genes   <- convert_to_mouse(Seurat::cc.genes.updated.2019$s.genes)
g2m.genes <- convert_to_mouse(Seurat::cc.genes.updated.2019$g2m.genes)
```

## Controllo qualità per campione

In questa fase viene valutata la qualità dei *nuclei* a partire dalle principali metriche di QC: numero totale di trascritti (*nCount_RNA*), numero di geni rilevati (*nFeature_RNA*) e percentuale di trascritti mitocondriali (*percent.mt*). Le distribuzioni vengono visualizzate tramite violin plot per campione e, inoltre, viene visualizzata la relazione tra *nCount_RNA* e *nFeature_RNA* mediante scatter plot. Queste visualizzazioni consentono di identificare profili a bassa complessità e possibili outlier,permettendo di scegliere le soglie di filtraggio opportune.

```{r qc, echo=TRUE, message=FALSE, eval=TRUE, warning=FALSE}
seurat_list <- purrr::imap(seurat_list, ~{
  obj <- .x
  obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^mt-")
  obj})
bone <- Reduce(function(x, y) merge(x, y), seurat_list)
```

```{r save-marge_qc, eval=TRUE, echo=TRUE}
saveRDS(bone, paste0(intermediate_pre_path, "bone_qc_merged.rds"))
```

```{r qc-plots, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=4}
p1 <- VlnPlot(
  bone,
  features = c("nFeature_RNA", "nCount_RNA", "percent.mt"),
  group.by = "sample",
  ncol = 3,
  pt.size = 0.1
) + ggplot2::scale_y_continuous(labels = function(x) format(x, big.mark = ".", decimal.mark = ",", scientific = FALSE))

p2 <- FeatureScatter(
  bone,
  feature1 = "nCount_RNA",
  feature2 = "nFeature_RNA",
  group.by = "sample"
) + ggplot2::geom_smooth(method = "lm", se = FALSE) +
    ggplot2::scale_y_continuous(labels = function(x) format(x, big.mark = ".", decimal.mark = ",", scientific = FALSE))
p1
p2
```

```{r save-qc-plots_raw, eval=TRUE, echo=TRUE}
ggsave(
  filename = paste0(plots_path, "QC_violin_raw.png"),
  plot = p1,
  width = 12,
  height = 4,
  dpi = 300)
ggsave(
  filename = paste0(plots_path, "QC_scatter_raw.png"),
  plot = p2,
  width = 6,
  height = 5,
  dpi = 300)
```

## Filtraggio QC per campione

Il filtraggio dei *nuclei* è stato eseguito separatamente per campione applicando le seguenti soglie: *nFeature_RNA* tra 500 e 6.500, *nCount_RNA* tra 1.000 e 20.000 e *percent.mt* < 5%.  
Inoltre, i geni mitocondriali sono stati esclusi dalle feature utilizzate nelle analisi successive, poiché possono riflettere profili di bassa qualità e introdurre variabilità tecnica non informativa.


```{r filtro-qc, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
caps <- tibble::tribble(
  ~sample,     ~min_feat, ~max_feat, ~min_count, ~max_count, ~max_mt,
  "bone_WT1",       500,      6500,       1000,      20000,      5,
  "bone_WT2",       500,      6500,       1000,      20000,      5,
  "bone_MUT1",      500,      6500,       1000,      20000,      5,
  "bone_MUT2",      500,      6500,       1000,      20000,      5
)

before <- sapply(seurat_list, ncol)
seurat_list <- imap(seurat_list, ~{
  obj <- .x; s <- .y
  thr <- filter(caps, sample == s)
  if (!"percent.mt" %in% colnames(obj@meta.data)) {
    obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern="^mt-")
  }
  subset(obj, subset =
    nFeature_RNA > thr$min_feat &
    nFeature_RNA < thr$max_feat &
    nCount_RNA   > thr$min_count &
    nCount_RNA   < thr$max_count &
    percent.mt   < thr$max_mt
  )
})
after <- sapply(seurat_list, ncol)
data.frame(
  sample       = names(seurat_list),
  cells_before = before[names(seurat_list)],
  cells_after  = after,
  kept_pct     = round(100 * after / before[names(seurat_list)], 2))

mito <- unique(unlist(lapply(seurat_list, function(o){grep("^mt-", rownames(o), value = TRUE, ignore.case = TRUE)})))
cat("Numero di geni mitocondriali trovati:", length(mito), "\n")
seurat_list <- purrr::imap(seurat_list, ~{
obj <- .x
keep_features <- setdiff(rownames(obj), mito)
subset(obj, features = keep_features)})
sapply(seurat_list, function(o) sum(grepl("^mt-", rownames(o), ignore.case = TRUE)))
```

```{r save-objects, eval=FALSE, include=FALSE}
saveRDS(seurat_list, paste0(intermediate_pre_path, "seurat_list_filtered.rds"))
```

```{r qc-plots-postfiltro, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE, fig.width=10, fig.height=4}
bone <- Reduce(function(x, y) merge(x, y), seurat_list)
p1 <- VlnPlot(
  bone,
  features = c("nFeature_RNA", "nCount_RNA", "percent.mt"),
  group.by = "sample",
  ncol = 3,
  pt.size = 0.1) + 
ggplot2::scale_y_continuous(labels = function(x) format(x, big.mark = ".", decimal.mark = ",", scientific = FALSE))

p2 <- FeatureScatter(
  bone,
  feature1 = "nCount_RNA",
  feature2 = "nFeature_RNA",
  group.by = "sample"
) + 
  ggplot2::geom_smooth(method = "lm", se = FALSE) +
  ggplot2::scale_y_continuous(labels = function(x) format(x, big.mark = ".", decimal.mark = ",", scientific = FALSE))
p1
p2
```

```{r save-qc-plots-postfilter, eval=TRUE, echo=TRUE}
ggsave(
  filename = paste0(plots_path, "QC_violin_postfilter.png"),
  plot = p1,
  width = 12,
  height = 4,
  dpi = 300)

ggsave(
  filename = paste0(plots_path, "QC_scatter_postfilter.png"),
  plot = p2,
  width = 6,
  height = 5,
  dpi = 300)
```

## Rimozione effetto del ciclo cellulare



Per valutare se il ciclo cellulare rappresentasse un potenziale fattore confondente, sono stati calcolati gli score di fase *S* (*S.Score*) e *G2/M* (*G2M.Score*) utilizzando le liste geniche caricate prima. Sulla base di tali score, a ciascun *nucleo* è stata assegnata la fase del ciclo cellulare (*G1*, *S*, *G2/M*).
Successivamente, è stata eseguita una PCA dedicata sui geni del ciclo cellulare e la proiezione è stata visualizzata colorando i nuclei per fase. La presenza di una separazione associata alle fasi del ciclo cellulare indica che questa componente contribuisce alla variabilità osservata.
Per ridurre l’influenza del ciclo cellulare sulle analisi downstream, gli score *S.Score* e *G2M.Score* sono stati regressi durante lo scaling dei dati, ottenendo una riduzione della variabilità legata al ciclo cellulare.


```{r ciclo-cellulare-setup_, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
seurat_list <- imap(seurat_list, ~{
  obj <- .x
  DefaultAssay(obj) <- "RNA"
  obj <- NormalizeData(obj)
  obj <- CellCycleScoring(
    obj,
    s.features = s.genes,
    g2m.features = g2m.genes,
    set.ident = FALSE)
  obj
})
```

```{r save-cycle-objects, eval=TRUE, echo=TRUE}
saveRDS(seurat_list, paste0(intermediate_pre_path, "seurat_list_with_cycle.rds"))
```

```{r cycle_genes_merge, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
bone <- Reduce(function(x, y) merge(x, y), seurat_list)
DefaultAssay(bone) <- "RNA"
cycle.genes <- unique(c(s.genes, g2m.genes))
bone <- ScaleData(bone, features = cycle.genes)
bone<- RunPCA(bone, features = cycle.genes, npcs = 40, reduction.name = "pca_cycle", verbose = FALSE)
```

```{r ciclo-cellulare-diagnostico, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
p_cc <- DimPlot(
  bone,
  reduction = "pca_cycle",
  group.by = "Phase"
) + ggtitle(" Effetto del ciclo cellulare (pre-regressione)")
p_cc
```

```{r plot_pre_regressione, eval=TRUE, echo=TRUE}
ggsave(
  filename = paste0(plots_path, "PCA_ciclo_cellulare_pre_regressione.png"),
  plot = p_cc,
  width = 6,
  height = 5,
  dpi = 300)
```


```{r pca, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
bone <- FindVariableFeatures(bone, selection.method = "vst", nfeatures = 2000)
bone <- ScaleData(bone)
bone <- RunPCA(bone, features = VariableFeatures(bone), npcs = 50, reduction.name = "pca_prereg")

```


```{r elbowplot-before-regression, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
p_elbow <- ElbowPlot(bone, reduction = "pca_prereg", ndims = 50) +
  ggtitle(" Pre-regressione")
p_elbow
```

```{r umap-preregression, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE,  results='hide'}
bone <- FindNeighbors(bone, reduction = "pca_prereg", dims = 1:40)
bone <- RunUMAP(bone, reduction = "pca_prereg", dims = 1:40, reduction.name = "umap_prereg")
```

```{r plot-umap-preregression-noclusters, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
p_umap_phase <- DimPlot(bone, reduction = "umap_prereg", group.by = "Phase") +
  ggtitle("Pre-regressione") +
  xlab("UMAP_1") + ylab("UMAP_2")

p_umap_phase
```

```{r save_umap_pre_regressione, eval=TRUE, echo=TRUE}
ggsave(
  filename = paste0(plots_path, "UMAP_fasi_ciclo_pre_regressione.png"),
  plot = p_umap_phase,
  width = 6,
  height = 5,
  dpi = 300)
```

```{r save-postumap-preregression, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
saveRDS(bone, paste0(intermediate_pre_path, "bone_postumap_preregression.rds"))
```

```{r scala_data, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
bone <- ScaleData(
  bone,
  vars.to.regress = c("S.Score", "G2M.Score"),
  features = VariableFeatures(bone))
bone <- RunPCA(bone, features = VariableFeatures(bone), npcs = 50, reduction.name = "pca_postreg")
```

```{r elbowplot-post-regression, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
p_elbow_post <- ElbowPlot(bone, reduction = "pca_postreg", ndims = 50) +
  ggtitle("ElbowPlot - post regressione")
p_elbow_post
```

```{r umap-post-regression, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
bone <- FindNeighbors(bone, reduction = "pca_postreg", dims = 1:40)
bone <- RunUMAP(bone, reduction = "pca_postreg", dims = 1:40, reduction.name = "umap_postreg")
```

```{r plot-umap-postregression, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
p_umap_post <- DimPlot(bone, reduction = "umap_postreg", group.by = "Phase") +
  ggtitle("Post-regressione") +
  xlab("UMAP_1") + ylab("UMAP_2")

p_umap_post
```

```{r save_umap_post_regressione, eval=TRUE, echo=TRUE}
ggsave(
  filename = paste0(plots_path, "UMAP_fasi_ciclo_post_regressione.png"),
  plot = p_umap_post,
  width = 6,
  height = 5,
  dpi = 300
)
```

```{r save-merge-postregression, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
saveRDS(bone, paste0(intermediate_pre_path, "bone_postregression.rds"))
```

## Preprocessing per campione

Per ciascun campione sono stati eseguiti i passaggi di preprocessing necessari alle analisi successive, includendo l’identificazione delle *feature altamente variabili*, lo *scaling* dei dati e il calcolo della *PCA*. La normalizzazione non viene ripetuta in questa fase poiché è già stata effettuata nei passaggi precedenti (scoring/regressione del ciclo cellulare).


```{r preprocessing-base-setup, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
seurat_list <- imap(seurat_list, ~{
  obj <- .x
  DefaultAssay(obj) <- "RNA"   
  obj <- FindVariableFeatures(obj, selection.method = "vst", nfeatures = 2000)
  obj <- ScaleData(obj)
  obj <- RunPCA(obj, features = VariableFeatures(obj), npcs = 50)
  obj
})
```

```{r elbowplot, echo=TRUE, eval=TRUE}
imap(seurat_list, ~{
  p <- ElbowPlot(.x, ndims = 50) + ggtitle(.y)
  print(p)
})
```

```{r clustering-umap-setup, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
pcs_to_use <- 1:40
resolution <- 0.3  
seurat_list <- imap(seurat_list, ~{
  obj <- .x
 DefaultAssay(obj) <- "RNA"
  obj <- FindNeighbors(obj, dims = pcs_to_use)
  obj <- FindClusters(obj, resolution = resolution)
  obj <- RunUMAP(obj, dims = pcs_to_use)
  obj
})
```

```{r umap-clustering-plot, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
plots <- imap(seurat_list, ~{
  sample <- .y
  DimPlot(
    .x,
    reduction = "umap",
    group.by = "seurat_clusters",
    label = TRUE
  ) +
    ggtitle(paste("Clustering –", sample)) +
    xlab("UMAP_1") + ylab("UMAP_2")
})

plots
```

```{r save-preprocessed, eval=TRUE}
saveRDS(seurat_list, file = paste0(intermediate_pre_path, "seurat_list_preprocessed.rds"))
```

## Identificazione e rimozione dei doublet

Durante la preparazione *single-nucleus RNA-seq* può accadere che due *nuclei* vengano catturati nella stessa goccia, generando i cosiddetti *doublet*. Questi profili ibridi non rappresentano uno stato biologico reale e possono introdurre bias nelle analisi downstream.
L’identificazione dei *doublet* è stata eseguita con *DoubletFinder*. Per ciascun campione è stato ottimizzato il parametro *pK* tramite una procedura di *parameter sweep* e stimato il numero atteso di *doublet*, includendo una correzione per i *doublet* omotipici. I nuclei classificati come *Doublet* sono stati rimossi, mantenendo esclusivamente i *Singlet* per le analisi successive.


```{r sweep-pK-per-sample, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE, results='hide', fig.show='hide'}
pk_results <- list()
seurat_list <- imap(seurat_list, ~{
  obj <- .x
  sample <- .y
   DefaultAssay(obj) <- "RNA"
  sweep.res.list <- paramSweep(obj, PCs = 1:40, sct = FALSE)
  sweep.stats <- summarizeSweep(sweep.res.list, GT = FALSE)
  bcmvn <- find.pK(sweep.stats)
  
  pk_results[[sample]] <<- bcmvn
  best.pK <- bcmvn %>%
    filter(BCmetric == max(BCmetric)) %>%
    pull(pK) %>%
    as.character() %>%
    as.numeric()
  
  attr(obj, "best.pK") <- best.pK
  
  obj
})
```

```{r extract-best-pk, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
best_pks <- imap(pk_results, ~{
  bcmvn <- .x
  sample <- .y

  best_row <- bcmvn[which.max(bcmvn$BCmetric), ]
  best_pK <- as.numeric(as.character(best_row$pK))

  tibble(sample = sample, best.pK = best_pK)
}) %>% bind_rows()

print(best_pks)
```

```{r run-doubletfinder-setup, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
seurat_list <- imap(seurat_list, ~{
  obj <- .x
  DefaultAssay(obj) <- "RNA"
  best.pK <- attr(obj, "best.pK")

  obj <- FindNeighbors(obj, dims = 1:40)
  obj <- FindClusters(obj, resolution = 0.3)

  annotations <- obj@meta.data$seurat_clusters
  homotypic.prop <- modelHomotypic(annotations)

  nExp <- round(0.075 * ncol(obj))
  nExp.adj <- round(nExp * (1 - homotypic.prop))

  obj <- doubletFinder(
    seu = obj,
    PCs = 1:40,
    pN = 0.25,
    pK = best.pK,
    nExp = nExp.adj,
    sct = FALSE
  )

  df_cols <- grep("^DF.classifications", colnames(obj@meta.data), value = TRUE)
  if (length(df_cols) > 0) {
    colnames(obj@meta.data)[colnames(obj@meta.data) == df_cols[length(df_cols)]] <- "DF.classifications"
  }
  obj
})
```

```{r plot-doublets-umap, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE, results='asis'}
iwalk(seurat_list, ~{
  p <- DimPlot(
    .x,
    reduction = "umap",
    group.by = "DF.classifications",
    pt.size = 0.5
  ) +
    ggtitle(.y) +
    xlab("UMAP_1") + ylab("UMAP_2")
  print(p)
  
conteggi <- .x$DF.classifications

n_singlet <- sum(conteggi == "Singlet", na.rm = TRUE)
n_doublet <- sum(conteggi == "Doublet", na.rm = TRUE)

cat(sprintf(
  "Singlet: %d<br>Doublet: %d<br><br>",
  n_singlet, n_doublet))
})
```

I nuclei classificati come Doublet vengono rimossi e viene verificato, per ciascun campione, il numero di nuclei mantenuti dopo il filtraggio.

```{r filter-doublets, eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
seurat_list <- imap(seurat_list, ~ subset(.x, DF.classifications == "Singlet"))
after_summary <- sapply(seurat_list, ncol)
after_df <- data.frame(
  sample = names(after_summary),
  singlets_after = after_summary)
print(after_df)
```

## Controllo pre-integrazione dell’effetto batch
Prima dell’integrazione, i campioni filtrati (solo *Singlet*) sono stati uniti in un unico oggetto (*bone_singlets*). Su questo oggetto sono stati eseguiti normalizzazione, identificazione delle *feature altamente variabili* (HVG), *scaling* e *PCA*, al fine di valutare la struttura dei dati e l’eventuale presenza di separazioni guidate dal campione prima dell’integrazione.

```{r umap-before-integration-setup, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
bone_singlets <- Reduce(function(x, y) merge(x, y), seurat_list)
DefaultAssay(bone_singlets) <- "RNA"
bone_singlets <- NormalizeData(bone_singlets)
bone_singlets <- FindVariableFeatures(bone_singlets, selection.method = "vst", nfeatures = 2000)
bone_singlets <- ScaleData(bone_singlets)
bone_singlets <- RunPCA(bone_singlets, features = VariableFeatures(bone_singlets), npcs = 50 )
```

```{r elbowplot-before-integration, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
p_elbow_preint <- ElbowPlot(bone_singlets, ndims = 50) + 
  ggtitle("ElbowPlot – pre integrazione")
p_elbow_preint
```

```{r umap_pre_integrazione, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
bone_singlets <- FindNeighbors(bone_singlets, reduction = "pca", dims = 1:40)
bone_singlets <- RunUMAP(bone_singlets, reduction="pca", dims=1:40, reduction.name="umap_preint")
```

```{r save_pre_integrazione, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE}
saveRDS(
  bone_singlets,
  file = paste0(intermediate_pre_path, "bone_singlets_preint.rds"))
```


```{r umap-plot-before-integration, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
p_umap_preint <- DimPlot(
  bone_singlets,
  reduction = "umap_preint",
  group.by = "orig.ident",
  label = FALSE
) +
  ggtitle("Pre-integrazione") +
  xlab("UMAP_1") + ylab("UMAP_2")

p_umap_preint
```

```{r save_umap_pre_integrazione, eval=TRUE, echo=TRUE}
ggsave(
  filename = paste0(plots_path, "UMAP_pre_integrazione.png"),
  plot = p_umap_preint,
  width = 6,
  height = 5,
  dpi = 300
)
```

## Integrazione CCA

I campioni sono stati integrati per ridurre l’effetto batch mediante un approccio *anchor-based* basato su *CCA*. La riduzione integrata è stata utilizzata per UMAP e analisi downstream, ottenendo l’oggetto integrato finale.

```{r integration-cca, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
bone_multi <- merge(x = seurat_list[[1]], y = seurat_list[2:4])
DefaultAssay(bone_multi) <- "RNA"
bone_multi <- NormalizeData(bone_multi)
bone_multi <- FindVariableFeatures(bone_multi, nfeatures = 2000)
bone_multi <- ScaleData(bone_multi)
bone_multi <- RunPCA(bone_multi, npcs = 50)
bone_multi <- IntegrateLayers(
  object = bone_multi,
  method = CCAIntegration,
  orig.reduction = "pca",
  new.reduction = "integrated.cca",
  dims = 1:40,
  assay = "RNA",
  verbose = FALSE
)
```

```{r dimplot-samples, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
pcs_to_use <- 1:40
bone_multi <- FindNeighbors(bone_multi, reduction = "integrated.cca", dims = pcs_to_use)
bone_multi <- RunUMAP(
  bone_multi,
  reduction = "integrated.cca",
  dims = pcs_to_use,
  reduction.name = "umap"
)
p_umap_samples <- DimPlot(
  bone_multi,
  reduction = "umap",
  group.by = "sample",
  label = FALSE,
  pt.size = 0.2
) +
  ggtitle("UMAP post-integrazione") +
  xlab("UMAP_1") + ylab("UMAP_2")

p_umap_samples
```

```{r save_umap_post_integrazione,eval=TRUE, echo=TRUE}
ggsave(
  filename = paste0(plots_path, "UMAP_post_integrazione.png"),
  plot = p_umap_samples,
  width = 6,
  height = 5,
  dpi = 300
)
```

Al termine delle **Fasi 1–2**, l’oggetto integrato finale (*bone_multi*) è stato salvato in formato *RDS* come `bone_multi_postintegration.rds` e utilizzato come input per le analisi successive.

```{r save-after-integration-umap, eval=TRUE, echo=TRUE}
saveRDS(bone_multi, file = paste0(intermediate_pre_path, "bone_multi_postintegration.rds"))
```

```{r session-info, echo=TRUE}
sessionInfo()
```
